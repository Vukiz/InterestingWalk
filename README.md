# InterestingWalk</br></br>
Постановка задачи</br>
 
Дан произвольный связный граф, не обязательно полный. У каждой вершины v ∈ V указан вес W ∈ R, что означает интерес вершины предположительно основанный на рейтинге людей. У каждого ребра соединяющего вершины [v1;v2] есть вес T означающий время необходимое для перехода из одной вершины в другую.</br>
Необходимо построить маршрут из начальной вершины Vo в конечную (в текущих условиях задачи стартовая вершина является конечной) не превышающий по времени заданного и имеющий максимально возможный интерес из возможных. Время пути находится как сумма весов ребер пути. Вершины могут повторяться, но их интерес не учитывается повторно в текущем пути, в отличии от ребер ведущих в них.</br>

Сравнение с типовыми задачами</br>
Задача коммивояжера  - заключается в отыскании самого выгодного маршрута, проходящего через указанные города хотя бы по одному разу с последующим возвратом в исходный город.  Так как в нашей задаче неважно сколько раз мы будем проходить через какие вершины, решения задачи коммивояжера не удовлетворяют нашим условиям.</br>
Single vehicle pickup and delivery problem with hard windows - подразумевает, что мы должны посетить каждую вершину в течении необходимого ей времени. В нашей же задаче подмножество вершин из V, которые необходимо посетить неопределенно, ровно так же как и не указано время в течении которого их необходимо посетить. </br>



Решение</br>
Для решения этой задачи за основу был взят поиск в глубину.</br>
алгоритм проходит в два этапа и заключается в следующем:</br>
1.Инициализация </br>
1.1 Выделяем память и находим расстояния от старта до каждой из вершин графа(по алгоритму форда беллмана)</br>
1.2 Рассчитываем максимальный интерес графа (сумма всех интересов) </br></br>
2. Поиск в глубину</br> 
2.1 Если в пути задействованы все вершины =>(Пункт 3)
Из текущей (в начале это вершина “Start”) в каждой смежной с ней вершине вызываем поиск с текущим путем равным {текущий путь + смежная вершина} </br>
2.2 если в пути есть повтор ( Start - 1- Start - 1) переходим в пункт 3 </br>
2.3 рассматриваем каждую смежную с текущей вершину - 
если( время текущего пути + время до смежной + расстояние от вершины до старта) > временного ограничения(time restriction) - переходим в пункт 3 </br>
2.4 иначе 2.1 </br></br>
3. Возврат </br>
3.1 если мы в начальной вершине - сравнить текущий путь с лучшим и обновить его если нужно </br>
3.2 если в пути есть повтор ( Start - 1- Start - 1) - отсеять его.</br>
3.3 рассматриваем каждую смежную с текущей вершину - если время до смежной + время от смежной до старта + время текущего пути <= time restriction - добавляем смежную в текущий путь и вызываем Возврат(3) из смежной </br></br>
 
Так как каждая ветвь поиска независима от других алгоритм отлично параллелится, что существенно сокращает время выполнения. </br>
Отбрасывание повторяющихся и зацикливающихся ветвей также позволяет ускорить выполнение алгоритма.</br>
Таким образом относительно простая реализация алгоритма позволяет достаточно быстро найти нужный путь.</br>
К минусам данного решения несомненно относится количество необходимых для рассмотрения </br>
вариантов, а следовательно и время выполнения.</br>
 
 
Возможное улучшение решения
Также возможно реализовать решение на основе метода ветвей и границ.
Для этого для каждой вершины вводится оценка (точнее множество оценок, в зависимости от рассматриваемого ребра) - Оценка = ИнтересВремя. 
Следующим шагом мы должны будем рассчитать расстояния от каждой вершины в каждую( в отличии от предыдущего решения, где нужно было рассчитывать расстояния только до начальной вершины) например алгоритмом Флойда-Уоршелла.
Имея в наличии данную информацию( расстояния и оценка каждой связки [Ребро+Вершина] ) мы можем оценить ветвь решения и таким образом выбирать для рассмотрения более оптимистичную ветвь.
Сделаем это следующим образом - ветвь оценивается как сумма всех оценок последующих вершин расстояния из которых до текущей вершины не убывает и расстояние до конечной вершины меньше оставшегося времени( то есть будет возможность вернуться)

