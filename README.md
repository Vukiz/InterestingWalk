# InterestingWalk
Постановка задачи
 
Дан произвольный связный граф, не обязательно полный. У каждой вершины v ∈ V указан вес W ∈ R, что означает интерес вершины предположительно основанный на рейтинге людей. У каждого ребра соединяющего вершины [v1;v2] есть вес T означающий время необходимое для перехода из одной вершины в другую.
Необходимо построить маршрут из начальной вершины Vo в конечную (в текущих условиях задачи стартовая вершина является конечной) не превышающий по времени заданного и имеющий максимально возможный интерес из возможных. Время пути находится как сумма весов ребер пути. Вершины могут повторяться, но их интерес не учитывается повторно в текущем пути, в отличии от ребер ведущих в них.

Сравнение с типовыми задачами
Задача коммивояжера  - заключается в отыскании самого выгодного маршрута, проходящего через указанные города хотя бы по одному разу с последующим возвратом в исходный город.  Так как в нашей задаче неважно сколько раз мы будем проходить через какие вершины, решения задачи коммивояжера не удовлетворяют нашим условиям.
Single vehicle pickup and delivery problem with hard windows - подразумевает, что мы должны посетить каждую вершину в течении необходимого ей времени. В нашей же задаче подмножество вершин из V, которые необходимо посетить неопределенно, ровно так же как и не указано время в течении которого их необходимо посетить. 



Решение
Для решения этой задачи за основу был взять поиск в глубину.
алгоритм проходит в два этапа и заключается в следующем:
1.Инициализация 
1.1 Выделяем память и находим расстояния от старта до каждой из вершин графа(по алгоритму форда беллмана)
1.2 Рассчитываем максимальный интерес графа (сумма всех интересов) 
2. Поиск в глубину 
2.1 Если в пути задействованы все вершины =>(Пункт 3)
Из текущей (в начале это вершина “Start”) в каждой смежной с ней вершине вызываем поиск с текущим путем равным {текущий путь + смежная вершина} 
2.2 если в пути есть повтор ( Start - 1- Start - 1) переходим в пункт 3 
2.3 рассматриваем каждую смежную с текущей вершину - 
если( время текущего пути + время до смежной + расстояние от вершины до старта) > временного ограничения(time restriction) - переходим в пункт 3 
2.4 иначе 2.1 
3. Возврат 
3.1 если мы в начальной вершине - сравнить текущий путь с лучшим и обновить его если нужно 
3.2 если в пути есть повтор ( Start - 1- Start - 1) - отсеять его.
3.3 рассматриваем каждую смежную с текущей вершину - если расстояние до смежной + расстояние от смежной до старта + время текущего пути <= time restriction - добавляем смежную в текущий путь и вызываем Возврат(3) из смежной 
 
Так как каждая ветвь поиска независима от других алгоритм отлично параллелится, что существенно сокращает время выполнения. Отбрасывание повторяющихся и зацикливающихся ветвей также позволяет ускорить выполнение алгоритма.
Таким образом относительно простая реализация алгоритма позволяет достаточно быстро найти нужный путь.
К минусам данного решения несомненно относится количество необходимых для рассмотрения 
вариантов, а следовательно и время выполнения.
 
 
Возможное улучшение решения
Также возможно реализовать решение на основе метода ветвей и границ.
Для этого для каждой вершины вводится оценка (точнее множество оценок, в зависимости от рассматриваемого ребра) - Оценка = ИнтересВремя. 
Следующим шагом мы должны будем рассчитать расстояния от каждой вершины в каждую( в отличии от предыдущего решения, где нужно было рассчитывать расстояния только до начальной вершины) например алгоритмом Флойда-Уоршелла.
Имея в наличии данную информацию( расстояния и оценка каждой связки [Ребро+Вершина] ) мы можем оценить ветвь решения и таким образом выбирать для рассмотрения более оптимистичную ветвь.
Сделаем это следующим образом - ветвь оценивается как сумма всех оценок последующих вершин расстояния из которых до текущей вершины не убывает и расстояние до конечной вершины меньше оставшегося времени( то есть будет возможность вернуться)

